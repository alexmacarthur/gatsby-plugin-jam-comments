(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('stream'), require('encoding'), require('http'), require('url'), require('https'), require('zlib')) :
  typeof define === 'function' && define.amd ? define(['react', 'stream', 'encoding', 'http', 'url', 'https', 'zlib'], factory) :
  (global = global || self, global.JamComments = factory(global.React, global.stream, global.encoding, global.http$1, global.url, global.https, global.zlib));
}(this, (function (React, stream, encoding, http$1, url, https, zlib) { 'use strict';

  var React__default = 'default' in React ? React['default'] : React;
  stream = stream && Object.prototype.hasOwnProperty.call(stream, 'default') ? stream['default'] : stream;
  encoding = encoding && Object.prototype.hasOwnProperty.call(encoding, 'default') ? encoding['default'] : encoding;
  http$1 = http$1 && Object.prototype.hasOwnProperty.call(http$1, 'default') ? http$1['default'] : http$1;
  url = url && Object.prototype.hasOwnProperty.call(url, 'default') ? url['default'] : url;
  https = https && Object.prototype.hasOwnProperty.call(https, 'default') ? https['default'] : https;
  zlib = zlib && Object.prototype.hasOwnProperty.call(zlib, 'default') ? zlib['default'] : zlib;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o) {
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var it,
        normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var types = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var ClientError =
    /** @class */
    function (_super) {
      __extends(ClientError, _super);

      function ClientError(response, request) {
        var _this = this;

        var message = ClientError.extractMessage(response) + ": " + JSON.stringify({
          response: response,
          request: request
        });
        _this = _super.call(this, message) || this;
        _this.response = response;
        _this.request = request; // this is needed as Safari doesn't support .captureStackTrace

        /* tslint:disable-next-line */

        if (typeof Error.captureStackTrace === 'function') {
          Error.captureStackTrace(_this, ClientError);
        }

        return _this;
      }

      ClientError.extractMessage = function (response) {
        try {
          return response.errors[0].message;
        } catch (e) {
          return "GraphQL Error (Code: " + response.status + ")";
        }
      };

      return ClientError;
    }(Error);

    exports.ClientError = ClientError;
  });
  unwrapExports(types);
  var types_1 = types.ClientError;

  // (MIT licensed)

  var BUFFER = Symbol('buffer');
  var TYPE = Symbol('type');

  var Blob = /*#__PURE__*/function () {
    function Blob() {
      _classCallCheck(this, Blob);

      this[TYPE] = '';
      var blobParts = arguments[0];
      var options = arguments[1];
      var buffers = [];

      if (blobParts) {
        var a = blobParts;
        var length = Number(a.length);

        for (var i = 0; i < length; i++) {
          var element = a[i];
          var buffer = void 0;

          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === 'string' ? element : String(element));
          }

          buffers.push(buffer);
        }
      }

      this[BUFFER] = Buffer.concat(buffers);
      var type = options && options.type !== undefined && String(options.type).toLowerCase();

      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }

    _createClass(Blob, [{
      key: "slice",
      value: function slice() {
        var size = this.size;
        var start = arguments[0];
        var end = arguments[1];
        var relativeStart, relativeEnd;

        if (start === undefined) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }

        if (end === undefined) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }

        var span = Math.max(relativeEnd - relativeStart, 0);
        var buffer = this[BUFFER];
        var slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        var blob = new Blob([], {
          type: arguments[2]
        });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    }, {
      key: "size",
      get: function get() {
        return this[BUFFER].length;
      }
    }, {
      key: "type",
      get: function get() {
        return this[TYPE];
      }
    }]);

    return Blob;
  }();

  Object.defineProperties(Blob.prototype, {
    size: {
      enumerable: true
    },
    type: {
      enumerable: true
    },
    slice: {
      enumerable: true
    }
  });
  Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: 'Blob',
    writable: false,
    enumerable: false,
    configurable: true
  });
  /**
   * fetch-error.js
   *
   * FetchError interface for operational errors
   */

  /**
   * Create FetchError instance
   *
   * @param   String      message      Error message for human
   * @param   String      type         Error type for machine
   * @param   String      systemError  For Node.js system error
   * @return  FetchError
   */

  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type; // when err.type is `system`, err.code contains system error code

    if (systemError) {
      this.code = this.errno = systemError.code;
    } // hide custom error implementation details from end-users


    Error.captureStackTrace(this, this.constructor);
  }

  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = 'FetchError';
  /**
   * body.js
   *
   * Body interface provides common methods for Request and Response
   */

  var _require = stream;
  var PassThrough = _require.PassThrough;
  var convert;

  try {
    convert = encoding.convert;
  } catch (e) {}

  var INTERNALS = Symbol('Body internals');
  /**
   * Body mixin
   *
   * Ref: https://fetch.spec.whatwg.org/#body
   *
   * @param   Stream  body  Readable stream
   * @param   Object  opts  Response options
   * @return  Void
   */

  function Body(body) {
    var _this = this;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$size = _ref.size;

    var size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    var timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

    if (body == null) {
      // body is undefined or null
      body = null;
    } else if (typeof body === 'string') ; else if (isURLSearchParams(body)) ; else if (body instanceof Blob) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') ; else if (body instanceof stream) ; else {
      // none of the above
      // coerce to string
      body = String(body);
    }

    this[INTERNALS] = {
      body: body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;

    if (body instanceof stream) {
      body.on('error', function (err) {
        _this[INTERNALS].error = new FetchError("Invalid response body while trying to fetch ".concat(_this.url, ": ").concat(err.message), 'system', err);
      });
    }
  }

  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },

    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },

    /**
     * Decode response as ArrayBuffer
     *
     * @return  Promise
     */
    arrayBuffer: function arrayBuffer() {
      return consumeBody.call(this).then(function (buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },

    /**
     * Return raw response as Blob
     *
     * @return Promise
     */
    blob: function blob() {
      var ct = this.headers && this.headers.get('content-type') || '';
      return consumeBody.call(this).then(function (buf) {
        return Object.assign( // Prevent copying
        new Blob([], {
          type: ct.toLowerCase()
        }), _defineProperty({}, BUFFER, buf));
      });
    },

    /**
     * Decode response as json
     *
     * @return  Promise
     */
    json: function json() {
      var _this2 = this;

      return consumeBody.call(this).then(function (buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError("invalid json response body at ".concat(_this2.url, " reason: ").concat(err.message), 'invalid-json'));
        }
      });
    },

    /**
     * Decode response as text
     *
     * @return  Promise
     */
    text: function text() {
      return consumeBody.call(this).then(function (buffer) {
        return buffer.toString();
      });
    },

    /**
     * Decode response as buffer (non-spec api)
     *
     * @return  Promise
     */
    buffer: function buffer() {
      return consumeBody.call(this);
    },

    /**
     * Decode response as text, while automatically detecting the encoding and
     * trying to decode to UTF-8 (non-spec api)
     *
     * @return  Promise
     */
    textConverted: function textConverted() {
      var _this3 = this;

      return consumeBody.call(this).then(function (buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  }; // In browsers, all properties are enumerable.

  Object.defineProperties(Body.prototype, {
    body: {
      enumerable: true
    },
    bodyUsed: {
      enumerable: true
    },
    arrayBuffer: {
      enumerable: true
    },
    blob: {
      enumerable: true
    },
    json: {
      enumerable: true
    },
    text: {
      enumerable: true
    }
  });

  Body.mixIn = function (proto) {
    var _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(Body.prototype)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var name = _step.value;

        // istanbul ignore else: future proof
        if (!(name in proto)) {
          var desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };
  /**
   * Consume and convert an entire Body to a Buffer.
   *
   * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
   *
   * @return  Promise
   */


  function consumeBody() {
    var _this4 = this;

    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError("body used already for: ".concat(this.url)));
    }

    this[INTERNALS].disturbed = true;

    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    } // body is null


    if (this.body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    } // body is string


    if (typeof this.body === 'string') {
      return Body.Promise.resolve(Buffer.from(this.body));
    } // body is blob


    if (this.body instanceof Blob) {
      return Body.Promise.resolve(this.body[BUFFER]);
    } // body is buffer


    if (Buffer.isBuffer(this.body)) {
      return Body.Promise.resolve(this.body);
    } // body is buffer


    if (Object.prototype.toString.call(this.body) === '[object ArrayBuffer]') {
      return Body.Promise.resolve(Buffer.from(this.body));
    } // istanbul ignore if: should never happen


    if (!(this.body instanceof stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    } // body is stream
    // get ready to actually consume the body


    var accum = [];
    var accumBytes = 0;
    var abort = false;
    return new Body.Promise(function (resolve, reject) {
      var resTimeout; // allow timeout on slow response body

      if (_this4.timeout) {
        resTimeout = setTimeout(function () {
          abort = true;
          reject(new FetchError("Response timeout while trying to fetch ".concat(_this4.url, " (over ").concat(_this4.timeout, "ms)"), 'body-timeout'));
        }, _this4.timeout);
      } // handle stream error, such as incorrect content-encoding


      _this4.body.on('error', function (err) {
        reject(new FetchError("Invalid response body while trying to fetch ".concat(_this4.url, ": ").concat(err.message), 'system', err));
      });

      _this4.body.on('data', function (chunk) {
        if (abort || chunk === null) {
          return;
        }

        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError("content size at ".concat(_this4.url, " over limit: ").concat(_this4.size), 'max-size'));
          return;
        }

        accumBytes += chunk.length;
        accum.push(chunk);
      });

      _this4.body.on('end', function () {
        if (abort) {
          return;
        }

        clearTimeout(resTimeout);

        try {
          resolve(Buffer.concat(accum));
        } catch (err) {
          // handle streams that have accumulated too much data (issue #414)
          reject(new FetchError("Could not create Buffer from response body for ".concat(_this4.url, ": ").concat(err.message), 'system', err));
        }
      });
    });
  }
  /**
   * Detect buffer encoding and convert to target encoding
   * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
   *
   * @param   Buffer  buffer    Incoming buffer
   * @param   String  encoding  Target encoding
   * @return  String
   */


  function convertBody(buffer, headers) {
    if (typeof convert !== 'function') {
      throw new Error('The package `encoding` must be installed to use the textConverted() function');
    }

    var ct = headers.get('content-type');
    var charset = 'utf-8';
    var res, str; // header

    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    } // no charset in content type, peek at response body for at most 1024 bytes


    str = buffer.slice(0, 1024).toString(); // html5

    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    } // html4


    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);

      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    } // xml


    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    } // found charset


    if (res) {
      charset = res.pop(); // prevent decode issues when sites use incorrect encoding
      // ref: https://hsivonen.fi/encoding-menu/

      if (charset === 'gb2312' || charset === 'gbk') {
        charset = 'gb18030';
      }
    } // turn raw buffers into a single utf-8 buffer


    return convert(buffer, 'UTF-8', charset).toString();
  }
  /**
   * Detect a URLSearchParams object
   * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
   *
   * @param   Object  obj     Object to detect by type or brand
   * @return  String
   */


  function isURLSearchParams(obj) {
    // Duck-typing as a necessary condition.
    if (_typeof(obj) !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
      return false;
    } // Brand-checking and more duck-typing as optional condition.


    return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
  }
  /**
   * Clone body given Res/Req instance
   *
   * @param   Mixed  instance  Response or Request instance
   * @return  Mixed
   */


  function _clone(instance) {
    var p1, p2;
    var body = instance.body; // don't allow cloning a used body

    if (instance.bodyUsed) {
      throw new Error('cannot clone body after it is used');
    } // check that body is a stream and not form-data object
    // note: we can't clone the form-data object without having it as a dependency


    if (body instanceof stream && typeof body.getBoundary !== 'function') {
      // tee instance body
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2); // set instance body to teed body and return the other teed body

      instance[INTERNALS].body = p1;
      body = p2;
    }

    return body;
  }
  /**
   * Performs the operation "extract a `Content-Type` value from |object|" as
   * specified in the specification:
   * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
   *
   * This function assumes that instance.body is present.
   *
   * @param   Mixed  instance  Response or Request instance
   */


  function extractContentType(instance) {
    var body = instance.body; // istanbul ignore if: Currently, because of a guard in Request, body
    // can never be null. Included here for completeness.

    if (body === null) {
      // body is null
      return null;
    } else if (typeof body === 'string') {
      // body is string
      return 'text/plain;charset=UTF-8';
    } else if (isURLSearchParams(body)) {
      // body is a URLSearchParams
      return 'application/x-www-form-urlencoded;charset=UTF-8';
    } else if (body instanceof Blob) {
      // body is blob
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      // body is buffer
      return null;
    } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
      // body is array buffer
      return null;
    } else if (typeof body.getBoundary === 'function') {
      // detect form data input from form-data module
      return "multipart/form-data;boundary=".concat(body.getBoundary());
    } else {
      // body is stream
      // can't really do much about this
      return null;
    }
  }
  /**
   * The Fetch Standard treats this as if "total bytes" is a property on the body.
   * For us, we have to explicitly get it with a function.
   *
   * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
   *
   * @param   Body    instance   Instance of Body
   * @return  Number?            Number of bytes, or null if not possible
   */


  function getTotalBytes(instance) {
    var body = instance.body; // istanbul ignore if: included for completion

    if (body === null) {
      // body is null
      return 0;
    } else if (typeof body === 'string') {
      // body is string
      return Buffer.byteLength(body);
    } else if (isURLSearchParams(body)) {
      // body is URLSearchParams
      return Buffer.byteLength(String(body));
    } else if (body instanceof Blob) {
      // body is blob
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      // body is buffer
      return body.length;
    } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
      // body is array buffer
      return body.byteLength;
    } else if (body && typeof body.getLengthSync === 'function') {
      // detect form data input from form-data module
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
      body.hasKnownLength && body.hasKnownLength()) {
        // 2.x
        return body.getLengthSync();
      }

      return null;
    } else {
      // body is stream
      // can't really do much about this
      return null;
    }
  }
  /**
   * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
   *
   * @param   Body    instance   Instance of Body
   * @return  Void
   */


  function writeToStream(dest, instance) {
    var body = instance.body;

    if (body === null) {
      // body is null
      dest.end();
    } else if (typeof body === 'string') {
      // body is string
      dest.write(body);
      dest.end();
    } else if (isURLSearchParams(body)) {
      // body is URLSearchParams
      dest.write(Buffer.from(String(body)));
      dest.end();
    } else if (body instanceof Blob) {
      // body is blob
      dest.write(body[BUFFER]);
      dest.end();
    } else if (Buffer.isBuffer(body)) {
      // body is buffer
      dest.write(body);
      dest.end();
    } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
      // body is array buffer
      dest.write(Buffer.from(body));
      dest.end();
    } else {
      // body is stream
      body.pipe(dest);
    }
  } // expose Promise


  Body.Promise = global.Promise;
  /**
   * headers.js
   *
   * Headers class offers convenient helpers
   */

  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

  function validateName(name) {
    name = "".concat(name);

    if (invalidTokenRegex.test(name)) {
      throw new TypeError("".concat(name, " is not a legal HTTP header name"));
    }
  }

  function validateValue(value) {
    value = "".concat(value);

    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError("".concat(value, " is not a legal HTTP header value"));
    }
  }
  /**
   * Find the key in the map object given a header name.
   *
   * Returns undefined if not found.
   *
   * @param   String  name  Header name
   * @return  String|Undefined
   */


  function find(map, name) {
    name = name.toLowerCase();

    for (var key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }

    return undefined;
  }

  var MAP = Symbol('map');

  var Headers = /*#__PURE__*/function () {
    /**
     * Headers class
     *
     * @param   Object  headers  Response headers
     * @return  Void
     */
    function Headers() {
      _classCallCheck(this, Headers);

      var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this[MAP] = Object.create(null);

      if (init instanceof Headers) {
        var rawHeaders = init.raw();
        var headerNames = Object.keys(rawHeaders);

        for (var _i = 0, _headerNames = headerNames; _i < _headerNames.length; _i++) {
          var headerName = _headerNames[_i];

          var _iterator2 = _createForOfIteratorHelper(rawHeaders[headerName]),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var value = _step2.value;
              this.append(headerName, value);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }

        return;
      } // We don't worry about converting prop to ByteString here as append()
      // will handle it.


      if (init == null) ; else if (_typeof(init) === 'object') {
        var method = init[Symbol.iterator];

        if (method != null) {
          if (typeof method !== 'function') {
            throw new TypeError('Header pairs must be iterable');
          } // sequence<sequence<ByteString>>
          // Note: per spec we have to first exhaust the lists then process them


          var pairs = [];

          var _iterator3 = _createForOfIteratorHelper(init),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _pair = _step3.value;

              if (_typeof(_pair) !== 'object' || typeof _pair[Symbol.iterator] !== 'function') {
                throw new TypeError('Each header pair must be iterable');
              }

              pairs.push(Array.from(_pair));
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          for (var _i2 = 0, _pairs = pairs; _i2 < _pairs.length; _i2++) {
            var pair = _pairs[_i2];

            if (pair.length !== 2) {
              throw new TypeError('Each header pair must be a name/value tuple');
            }

            this.append(pair[0], pair[1]);
          }
        } else {
          // record<ByteString, ByteString>
          for (var _i3 = 0, _Object$keys = Object.keys(init); _i3 < _Object$keys.length; _i3++) {
            var key = _Object$keys[_i3];
            var _value = init[key];
            this.append(key, _value);
          }
        }
      } else {
        throw new TypeError('Provided initializer must be an object');
      }
    }
    /**
     * Return combined header value given name
     *
     * @param   String  name  Header name
     * @return  Mixed
     */


    _createClass(Headers, [{
      key: "get",
      value: function get(name) {
        name = "".concat(name);
        validateName(name);
        var key = find(this[MAP], name);

        if (key === undefined) {
          return null;
        }

        return this[MAP][key].join(', ');
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */

    }, {
      key: "forEach",
      value: function forEach(callback) {
        var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        var pairs = getHeaders(this);
        var i = 0;

        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          var name = _pairs$i[0],
              value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */

    }, {
      key: "set",
      value: function set(name, value) {
        name = "".concat(name);
        value = "".concat(value);
        validateName(name);
        validateValue(value);
        var key = find(this[MAP], name);
        this[MAP][key !== undefined ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */

    }, {
      key: "append",
      value: function append(name, value) {
        name = "".concat(name);
        value = "".concat(value);
        validateName(name);
        validateValue(value);
        var key = find(this[MAP], name);

        if (key !== undefined) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */

    }, {
      key: "has",
      value: function has(name) {
        name = "".concat(name);
        validateName(name);
        return find(this[MAP], name) !== undefined;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */

    }, {
      key: "delete",
      value: function _delete(name) {
        name = "".concat(name);
        validateName(name);
        var key = find(this[MAP], name);

        if (key !== undefined) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */

    }, {
      key: "raw",
      value: function raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */

    }, {
      key: "keys",
      value: function keys() {
        return createHeadersIterator(this, 'key');
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */

    }, {
      key: "values",
      value: function values() {
        return createHeadersIterator(this, 'value');
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */

    }, {
      key: Symbol.iterator,
      value: function value() {
        return createHeadersIterator(this, 'key+value');
      }
    }]);

    return Headers;
  }();

  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: 'Headers',
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: {
      enumerable: true
    },
    forEach: {
      enumerable: true
    },
    set: {
      enumerable: true
    },
    append: {
      enumerable: true
    },
    has: {
      enumerable: true
    },
    delete: {
      enumerable: true
    },
    keys: {
      enumerable: true
    },
    values: {
      enumerable: true
    },
    entries: {
      enumerable: true
    }
  });

  function getHeaders(headers) {
    var kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';
    var keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === 'key' ? function (k) {
      return k.toLowerCase();
    } : kind === 'value' ? function (k) {
      return headers[MAP][k].join(', ');
    } : function (k) {
      return [k.toLowerCase(), headers[MAP][k].join(', ')];
    });
  }

  var INTERNAL = Symbol('internal');

  function createHeadersIterator(target, kind) {
    var iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target: target,
      kind: kind,
      index: 0
    };
    return iterator;
  }

  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next: function next() {
      // istanbul ignore if
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError('Value of `this` is not a HeadersIterator');
      }

      var _INTERNAL = this[INTERNAL];
      var target = _INTERNAL.target,
          kind = _INTERNAL.kind,
          index = _INTERNAL.index;
      var values = getHeaders(target, kind);
      var len = values.length;

      if (index >= len) {
        return {
          value: undefined,
          done: true
        };
      }

      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: 'HeadersIterator',
    writable: false,
    enumerable: false,
    configurable: true
  });
  /**
   * Export the Headers object in a form that Node.js can consume.
   *
   * @param   Headers  headers
   * @return  Object
   */

  function exportNodeCompatibleHeaders(headers) {
    var obj = Object.assign({
      __proto__: null
    }, headers[MAP]); // http.request() only supports string as Host header. This hack makes
    // specifying custom Host header possible.

    var hostHeaderKey = find(headers[MAP], 'Host');

    if (hostHeaderKey !== undefined) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }

    return obj;
  }
  /**
   * Create a Headers object from an object of headers, ignoring those that do
   * not conform to HTTP grammar productions.
   *
   * @param   Object  obj  Object of headers
   * @return  Headers
   */


  function createHeadersLenient(obj) {
    var headers = new Headers();

    for (var _i4 = 0, _Object$keys2 = Object.keys(obj); _i4 < _Object$keys2.length; _i4++) {
      var name = _Object$keys2[_i4];

      if (invalidTokenRegex.test(name)) {
        continue;
      }

      if (Array.isArray(obj[name])) {
        var _iterator4 = _createForOfIteratorHelper(obj[name]),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var val = _step4.value;

            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }

            if (headers[MAP][name] === undefined) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }

    return headers;
  }
  /**
   * response.js
   *
   * Response class provides content decoding
   */


  var STATUS_CODES = http$1.STATUS_CODES;
  var INTERNALS$1 = Symbol('Response internals');
  /**
   * Response class
   *
   * @param   Stream  body  Readable stream
   * @param   Object  opts  Response options
   * @return  Void
   */

  var Response = /*#__PURE__*/function () {
    function Response() {
      _classCallCheck(this, Response);

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Body.call(this, body, opts);
      var status = opts.status || 200;
      this[INTERNALS$1] = {
        url: opts.url,
        status: status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers: new Headers(opts.headers)
      };
    }

    _createClass(Response, [{
      key: "clone",

      /**
       * Clone this response
       *
       * @return  Response
       */
      value: function clone() {
        return new Response(_clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok
        });
      }
    }, {
      key: "url",
      get: function get() {
        return this[INTERNALS$1].url;
      }
    }, {
      key: "status",
      get: function get() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */

    }, {
      key: "ok",
      get: function get() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
    }, {
      key: "statusText",
      get: function get() {
        return this[INTERNALS$1].statusText;
      }
    }, {
      key: "headers",
      get: function get() {
        return this[INTERNALS$1].headers;
      }
    }]);

    return Response;
  }();

  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: {
      enumerable: true
    },
    status: {
      enumerable: true
    },
    ok: {
      enumerable: true
    },
    statusText: {
      enumerable: true
    },
    headers: {
      enumerable: true
    },
    clone: {
      enumerable: true
    }
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: 'Response',
    writable: false,
    enumerable: false,
    configurable: true
  });
  /**
   * request.js
   *
   * Request class contains server only options
   *
   * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
   */

  var format_url = url.format;
  var parse_url = url.parse;
  var INTERNALS$2 = Symbol('Request internals');
  /**
   * Check if a value is an instance of Request.
   *
   * @param   Mixed   input
   * @return  Boolean
   */

  function isRequest(input) {
    return _typeof(input) === 'object' && _typeof(input[INTERNALS$2]) === 'object';
  }
  /**
   * Request class
   *
   * @param   Mixed   input  Url or Request instance
   * @param   Object  init   Custom options
   * @return  Void
   */


  var Request = /*#__PURE__*/function () {
    function Request(input) {
      _classCallCheck(this, Request);

      var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var parsedURL; // normalize input

      if (!isRequest(input)) {
        if (input && input.href) {
          // in order to support Node.js' Url objects; though WHATWG's URL objects
          // will fall into this branch also (since their `toString()` will return
          // `href` property anyway)
          parsedURL = parse_url(input.href);
        } else {
          // coerce input to a string before attempting to parse
          parsedURL = parse_url("".concat(input));
        }

        input = {};
      } else {
        parsedURL = parse_url(input.url);
      }

      var method = init.method || input.method || 'GET';
      method = method.toUpperCase();

      if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
        throw new TypeError('Request with GET/HEAD method cannot have body');
      }

      var inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? _clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      var headers = new Headers(init.headers || input.headers || {});

      if (init.body != null) {
        var contentType = extractContentType(this);

        if (contentType !== null && !headers.has('Content-Type')) {
          headers.append('Content-Type', contentType);
        }
      }

      this[INTERNALS$2] = {
        method: method,
        redirect: init.redirect || input.redirect || 'follow',
        headers: headers,
        parsedURL: parsedURL
      }; // node-fetch-only options

      this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
      this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }

    _createClass(Request, [{
      key: "clone",

      /**
       * Clone this request
       *
       * @return  Request
       */
      value: function clone() {
        return new Request(this);
      }
    }, {
      key: "method",
      get: function get() {
        return this[INTERNALS$2].method;
      }
    }, {
      key: "url",
      get: function get() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
    }, {
      key: "headers",
      get: function get() {
        return this[INTERNALS$2].headers;
      }
    }, {
      key: "redirect",
      get: function get() {
        return this[INTERNALS$2].redirect;
      }
    }]);

    return Request;
  }();

  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: 'Request',
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: {
      enumerable: true
    },
    url: {
      enumerable: true
    },
    headers: {
      enumerable: true
    },
    redirect: {
      enumerable: true
    },
    clone: {
      enumerable: true
    }
  });
  /**
   * Convert a Request to Node.js http request options.
   *
   * @param   Request  A Request instance
   * @return  Object   The options object to be passed to http.request
   */

  function getNodeRequestOptions(request) {
    var parsedURL = request[INTERNALS$2].parsedURL;
    var headers = new Headers(request[INTERNALS$2].headers); // fetch step 1.3

    if (!headers.has('Accept')) {
      headers.set('Accept', '*/*');
    } // Basic fetch


    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError('Only absolute URLs are supported');
    }

    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError('Only HTTP(S) protocols are supported');
    } // HTTP-network-or-cache fetch steps 2.4-2.7


    var contentLengthValue = null;

    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = '0';
    }

    if (request.body != null) {
      var totalBytes = getTotalBytes(request);

      if (typeof totalBytes === 'number') {
        contentLengthValue = String(totalBytes);
      }
    }

    if (contentLengthValue) {
      headers.set('Content-Length', contentLengthValue);
    } // HTTP-network-or-cache fetch step 2.11


    if (!headers.has('User-Agent')) {
      headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
    } // HTTP-network-or-cache fetch step 2.15


    if (request.compress) {
      headers.set('Accept-Encoding', 'gzip,deflate');
    }

    if (!headers.has('Connection') && !request.agent) {
      headers.set('Connection', 'close');
    } // HTTP-network fetch step 4.2
    // chunked encoding is handled by Node.js


    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent: request.agent
    });
  }
  /**
   * index.js
   *
   * a request API compatible with window.fetch
   *
   * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
   */


  var http = http$1;
  var _require$3 = stream;
  var PassThrough$1 = _require$3.PassThrough;
  var _require2 = url;
  var resolve_url = _require2.resolve;
  /**
   * Fetch function
   *
   * @param   Mixed    url   Absolute url or Request instance
   * @param   Object   opts  Fetch options
   * @return  Promise
   */

  function fetch$1(url, opts) {
    // allow custom promise
    if (!fetch$1.Promise) {
      throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
    }

    Body.Promise = fetch$1.Promise; // wrap http.request into fetch

    return new fetch$1.Promise(function (resolve, reject) {
      // build request object
      var request = new Request(url, opts);
      var options = getNodeRequestOptions(request);
      var send = (options.protocol === 'https:' ? https : http).request; // send request

      var req = send(options);
      var reqTimeout;

      function finalize() {
        req.abort();
        clearTimeout(reqTimeout);
      }

      if (request.timeout) {
        req.once('socket', function (socket) {
          reqTimeout = setTimeout(function () {
            reject(new FetchError("network timeout at: ".concat(request.url), 'request-timeout'));
            finalize();
          }, request.timeout);
        });
      }

      req.on('error', function (err) {
        reject(new FetchError("request to ".concat(request.url, " failed, reason: ").concat(err.message), 'system', err));
        finalize();
      });
      req.on('response', function (res) {
        clearTimeout(reqTimeout);
        var headers = createHeadersLenient(res.headers); // HTTP fetch step 5

        if (fetch$1.isRedirect(res.statusCode)) {
          // HTTP fetch step 5.2
          var location = headers.get('Location'); // HTTP fetch step 5.3

          var locationURL = location === null ? null : resolve_url(request.url, location); // HTTP fetch step 5.5

          switch (request.redirect) {
            case 'error':
              reject(new FetchError("redirect mode is set to error: ".concat(request.url), 'no-redirect'));
              finalize();
              return;

            case 'manual':
              // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
              if (locationURL !== null) {
                headers.set('Location', locationURL);
              }

              break;

            case 'follow':
              // HTTP-redirect fetch step 2
              if (locationURL === null) {
                break;
              } // HTTP-redirect fetch step 5


              if (request.counter >= request.follow) {
                reject(new FetchError("maximum redirect reached at: ".concat(request.url), 'max-redirect'));
                finalize();
                return;
              } // HTTP-redirect fetch step 6 (counter increment)
              // Create a new Request object.


              var requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body
              }; // HTTP-redirect fetch step 9

              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                finalize();
                return;
              } // HTTP-redirect fetch step 11


              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
                requestOpts.method = 'GET';
                requestOpts.body = undefined;
                requestOpts.headers.delete('content-length');
              } // HTTP-redirect fetch step 15


              resolve(fetch$1(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        } // prepare response


        var body = res.pipe(new PassThrough$1());
        var response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers: headers,
          size: request.size,
          timeout: request.timeout
        }; // HTTP-network fetch step 12.1.1.3

        var codings = headers.get('Content-Encoding'); // HTTP-network fetch step 12.1.1.4: handle content codings
        // in following scenarios we ignore compression support
        // 1. compression support is disabled
        // 2. HEAD request
        // 3. no Content-Encoding header
        // 4. no content response (204)
        // 5. content not modified response (304)

        if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          resolve(new Response(body, response_options));
          return;
        } // For Node v6+
        // Be less strict when decoding compressed responses, since sometimes
        // servers send slightly invalid responses that are still accepted
        // by common browsers.
        // Always using Z_SYNC_FLUSH is what cURL does.


        var zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        }; // for gzip

        if (codings == 'gzip' || codings == 'x-gzip') {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          resolve(new Response(body, response_options));
          return;
        } // for deflate


        if (codings == 'deflate' || codings == 'x-deflate') {
          // handle the infamous raw deflate response from old servers
          // a hack for old IIS and Apache servers
          var raw = res.pipe(new PassThrough$1());
          raw.once('data', function (chunk) {
            // see http://stackoverflow.com/questions/37519828
            if ((chunk[0] & 0x0F) === 0x08) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }

            resolve(new Response(body, response_options));
          });
          return;
        } // otherwise, use response as-is


        resolve(new Response(body, response_options));
      });
      writeToStream(req, request);
    });
  }
  /**
   * Redirect code matching
   *
   * @param   Number   code  Status code
   * @return  Boolean
   */


  fetch$1.isRedirect = function (code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  }; // Needed for TypeScript.


  fetch$1.default = fetch$1; // expose Promise

  fetch$1.Promise = global.Promise;

  var nodePonyfill = createCommonjsModule(function (module, exports) {
    var realFetch = fetch$1.default || fetch$1;

    var fetch = function fetch(url, options) {
      // Support schemaless URIs on the server for parity with the browser.
      // Ex: //github.com/ -> https://github.com/
      if (/^\/\//.test(url)) {
        url = 'https:' + url;
      }

      return realFetch.call(this, url, options);
    };

    fetch.polyfill = false;
    module.exports = exports = fetch;
    exports.fetch = fetch;
    exports.Headers = fetch$1.Headers;
    exports.Request = fetch$1.Request;
    exports.Response = fetch$1.Response; // Needed for TypeScript.

    exports.default = fetch;
  });
  var nodePonyfill_1 = nodePonyfill.fetch;
  var nodePonyfill_2 = nodePonyfill.Headers;
  var nodePonyfill_3 = nodePonyfill.Request;
  var nodePonyfill_4 = nodePonyfill.Response;

  var fetch$2 = nodePonyfill.fetch.bind({});
  fetch$2.polyfill = true;

  if (!commonjsGlobal.fetch) {
    commonjsGlobal.fetch = fetch$2;
    commonjsGlobal.Response = nodePonyfill.Response;
    commonjsGlobal.Headers = nodePonyfill.Headers;
    commonjsGlobal.Request = nodePonyfill.Request;
  }

  var src = createCommonjsModule(function (module, exports) {

    var __assign = commonjsGlobal && commonjsGlobal.__assign || Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : new P(function (resolve) {
            resolve(result.value);
          }).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };

    var __generator = commonjsGlobal && commonjsGlobal.__generator || function (thisArg, body) {
      var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) {
          try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];

            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;

              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };

              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;

              case 7:
                op = _.ops.pop();

                _.trys.pop();

                continue;

              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }

                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }

                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }

                if (t && _.label < t[2]) {
                  _.label = t[2];

                  _.ops.push(op);

                  break;
                }

                if (t[2]) _.ops.pop();

                _.trys.pop();

                continue;
            }

            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };

    var __rest = commonjsGlobal && commonjsGlobal.__rest || function (s, e) {
      var t = {};

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
      }
      return t;
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var types_2 = types;
    exports.ClientError = types_2.ClientError;

    var GraphQLClient =
    /** @class */
    function () {
      function GraphQLClient(url, options) {
        this.url = url;
        this.options = options || {};
      }

      GraphQLClient.prototype.rawRequest = function (query, variables) {
        return __awaiter(this, void 0, void 0, function () {
          var _a, headers, others, body, response, result, headers_1, status_1, errorResult;

          return __generator(this, function (_b) {
            switch (_b.label) {
              case 0:
                _a = this.options, headers = _a.headers, others = __rest(_a, ["headers"]);
                body = JSON.stringify({
                  query: query,
                  variables: variables ? variables : undefined
                });
                return [4
                /*yield*/
                , fetch(this.url, __assign({
                  method: 'POST',
                  headers: Object.assign({
                    'Content-Type': 'application/json'
                  }, headers),
                  body: body
                }, others))];

              case 1:
                response = _b.sent();
                return [4
                /*yield*/
                , getResult(response)];

              case 2:
                result = _b.sent();

                if (response.ok && !result.errors && result.data) {
                  headers_1 = response.headers, status_1 = response.status;
                  return [2
                  /*return*/
                  , __assign({}, result, {
                    headers: headers_1,
                    status: status_1
                  })];
                } else {
                  errorResult = typeof result === 'string' ? {
                    error: result
                  } : result;
                  throw new types.ClientError(__assign({}, errorResult, {
                    status: response.status,
                    headers: response.headers
                  }), {
                    query: query,
                    variables: variables
                  });
                }
            }
          });
        });
      };

      GraphQLClient.prototype.request = function (query, variables) {
        return __awaiter(this, void 0, void 0, function () {
          var _a, headers, others, body, response, result, errorResult;

          return __generator(this, function (_b) {
            switch (_b.label) {
              case 0:
                _a = this.options, headers = _a.headers, others = __rest(_a, ["headers"]);
                body = JSON.stringify({
                  query: query,
                  variables: variables ? variables : undefined
                });
                return [4
                /*yield*/
                , fetch(this.url, __assign({
                  method: 'POST',
                  headers: Object.assign({
                    'Content-Type': 'application/json'
                  }, headers),
                  body: body
                }, others))];

              case 1:
                response = _b.sent();
                return [4
                /*yield*/
                , getResult(response)];

              case 2:
                result = _b.sent();

                if (response.ok && !result.errors && result.data) {
                  return [2
                  /*return*/
                  , result.data];
                } else {
                  errorResult = typeof result === 'string' ? {
                    error: result
                  } : result;
                  throw new types.ClientError(__assign({}, errorResult, {
                    status: response.status
                  }), {
                    query: query,
                    variables: variables
                  });
                }
            }
          });
        });
      };

      GraphQLClient.prototype.setHeaders = function (headers) {
        this.options.headers = headers;
        return this;
      };

      GraphQLClient.prototype.setHeader = function (key, value) {
        var headers = this.options.headers;

        if (headers) {
          headers[key] = value;
        } else {
          this.options.headers = (_a = {}, _a[key] = value, _a);
        }

        return this;

        var _a;
      };

      return GraphQLClient;
    }();

    exports.GraphQLClient = GraphQLClient;

    function rawRequest(url, query, variables) {
      return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
          client = new GraphQLClient(url);
          return [2
          /*return*/
          , client.rawRequest(query, variables)];
        });
      });
    }

    exports.rawRequest = rawRequest;

    function request(url, query, variables) {
      return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
          client = new GraphQLClient(url);
          return [2
          /*return*/
          , client.request(query, variables)];
        });
      });
    }

    exports.request = request;
    exports.default = request;

    function getResult(response) {
      return __awaiter(this, void 0, void 0, function () {
        var contentType;
        return __generator(this, function (_a) {
          contentType = response.headers.get('Content-Type');

          if (contentType && contentType.startsWith('application/json')) {
            return [2
            /*return*/
            , response.json()];
          } else {
            return [2
            /*return*/
            , response.text()];
          }
        });
      });
    }
  });
  unwrapExports(src);
  var src_1 = src.ClientError;
  var src_2 = src.GraphQLClient;
  var src_3 = src.rawRequest;
  var src_4 = src.request;

  var getClient = (function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        apiKey = _ref.apiKey,
        domain = _ref.domain;

    return new src_2("http://localhost:4000/graphql", {
      headers: {
        "Content-Type": "application/json",
        "x-api-key": apiKey,
        "x-domain": domain
      }
    });
  });

  var apiKey = process.env.GATSBY_JAM_COMMENTS_API_KEY;
  var domain = process.env.GATSBY_JAM_COMMENTS_DOMAIN;
  var CommentBox = (function () {
    var formRef = React.useRef(null);

    var submitComment = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
        var mutationParams, query, variables;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                e.preventDefault();
                mutationParams = _toConsumableArray(formRef.current.elements).reduce(function (obj, input) {
                  obj[input.name] = input.value;
                  return obj;
                }, {});
                query = "\n                mutation CreateComment($name: String!, $path: String!, $content: String!, $twitterHandle: String, $emailAddress: String){\n                    createComment(name: $name, path: $path, content: $content, twitterHandle: $twitterHandle, emailAddress: $emailAddress) {\n                        createdAt\n                        name\n                        twitterHandle\n                        emailAddress\n                        content\n                    }\n                }";
                variables = {
                  name: mutationParams.name,
                  content: mutationParams.content,
                  twitterHandle: mutationParams.twitterHandle,
                  emailAddress: mutationParams.emailAddress,
                  path: window.location.pathname
                };
                _context.next = 6;
                return getClient({
                  apiKey: apiKey,
                  domain: domain
                }).request(query, variables);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function submitComment(_x) {
        return _ref.apply(this, arguments);
      };
    }();

    return /*#__PURE__*/React__default.createElement("form", {
      onSubmit: submitComment,
      ref: formRef,
      className: "jc-Form"
    }, /*#__PURE__*/React__default.createElement("label", {
      className: "jc-Form-label"
    }, "Comment", /*#__PURE__*/React__default.createElement("textarea", {
      name: "content",
      required: true
    })), /*#__PURE__*/React__default.createElement("label", {
      className: "jc-Form-label"
    }, "Name", /*#__PURE__*/React__default.createElement("input", {
      type: "text",
      name: "name",
      required: true
    })), /*#__PURE__*/React__default.createElement("label", {
      className: "jc-Form-label"
    }, "Email Address", /*#__PURE__*/React__default.createElement("input", {
      type: "email",
      name: "emailAddress"
    })), /*#__PURE__*/React__default.createElement("label", {
      className: "jc-Form-label"
    }, "Twitter Handle", /*#__PURE__*/React__default.createElement("input", {
      type: "text",
      name: "twitterHandle"
    })), /*#__PURE__*/React__default.createElement("button", null, "Submit"));
  });

  var CommentList = (function (_ref) {
    var comments = _ref.comments;
    return /*#__PURE__*/React__default.createElement("ul", {
      className: "jc-CommentList"
    }, comments.map(function (comment) {
      return /*#__PURE__*/React__default.createElement("span", {
        key: comment.id
      }, "hello!") // <li key={comment.id} className={styles.comment}>
      //   <span className={styles.deets}>
      //     <h6 className={styles.name}>{comment.name}</h6>
      //     <span className={styles.date}>
      //       {prettyDate(comment.createdAt)}
      //     </span>
      //   </span>
      //   <div className={styles.content}>
      //     <p>{comment.content}</p>
      //   </div>
      // </li>
      ;
    }));
  });

  var index = (function (_ref) {
    var pageContext = _ref.pageContext;
    var comments = pageContext.comments || [];
    return /*#__PURE__*/React__default.createElement("div", {
      className: "jc-Shell"
    }, /*#__PURE__*/React__default.createElement("h3", null, "Comments"), /*#__PURE__*/React__default.createElement(CommentBox, null), /*#__PURE__*/React__default.createElement(CommentList, {
      comments: comments
    }));
  });

  return index;

})));
